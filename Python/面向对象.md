## 面向对象语法

### 面向对象三大特性

1. 封装
   - 定义类的准则
2. 继承
   - 设计类的技巧
   - 子类针对自己的特有需求，编写特定的代码
3. 多态
   - 多态可以增加代码的灵活度
   - 以继承和重写父类方法为前提
   - 是调用方法的技巧，不会影响到类的内部设计

### dir 内置函数

可以使用 dir 来查看一个对象里面都有什么方法。

下面是一些常用的方法/属性

| 序号 | 方法名     | 类型 | 作用                                   |
| ---- | ---------- | ---- | -------------------------------------- |
| 01   | `__new__`  | 方法 | 创建对象时，会被自动调用               |
| 02   | `__init__` | 方法 | 对象被初始化时，会被自动调用           |
| 03   | `__del__`  | 方法 | 对象被从内存中销毁前，会被自动调用     |
| 04   | `__dtr__`  | 方法 | 返回对象的描述信息，print 函数输出使用 |

### 定义简单的类

在Python中要定义一个只包含方法的类，语法格式如下：

```python
class 类名:
    def 方法1(self, 参数列表):
        pass
    def 方法2(self, 参数列表):
        pass
```

- 方法的定义格式和函数几乎一样
- 区别于第一个参数必须是 self 

### 初始化方法

- 当使用 `类名()` 创建方法时，会自动使用 `__init__(self)`
- 为对象属性设置初始值
- 在 `__init__` 方法内部，可以指定一个对象的属性
- 当一个对象从内存中销毁前，会自动调用 `__del__` 方法，类似于析构函数？
- 生命周期就是从一个类创建开始，调用`__del__` 后结束

### 身份运算符

身份运算符用来比较两个对象的内存地址是否一致，是否是同一个对象的引用。

- 在 Python 中针对于 `None` 比较时，建议用 `is` 判断

| 运算符   | 描述                                      | 实例                           |
| -------- | ----------------------------------------- | ------------------------------ |
| `is`     | is 是判断两个标识符是不是引用同一个对象   | x is y ，类似 id(x)==id(y)     |
| `is not` | id not 是判断两个标识符是不是引用不同对象 | x is not y ，类似 id(a)!=id(b) |

`is` 与 `==` 的区别

- `is` 是判断两个变量的地址是不是一样
- `==` 是判断两个变量的值是不是一样

### 定义私有函数或者变量

- 只需要再方法名前或者属性前面加上两个下划线 `__` 即可
- 私有成员只允许类内访问
- 私有犯法也不允许在类外使用

但是，并不是真正意义上的私有，只是解释器中做了处理。

- 处理方式，在名称前面加上 `_类名` => `_类名__名称`

```python
# 私有属性
print(xiaofang._Women__age)

# 私有方法
xiaofang._Women__secret()
```

### 继承

继承的语法：

```python
class 类名(父类名)：
	pass
```

- 子类继承父类，可以直接享受父类中已经封装好的方法
- 子类中应该根据职责，封装子类特有的属性和方法
- 继承具有传递性，子类可以继承祖先类的方法和属性
- 当父类的方法不能满足子类的足球，可以对父类方法进行重写，方法是定义同一方法

**对父类方法进行扩展**：

- 如果只是对父类方法进行扩展时：
  1. 在子类中重写父类方法
  2. 在需要的位置使用 `super().父类方法()` 来调用父类方法的执行
  3. 代码的其他位置针对子类的需求，编写**子类特有的代码实现**
- 关于 `super`
  1. 在 Python 中是一个特殊的类
  2. `super()` 就是使用 `super` 类创建出来的对象
  3. 最常使用的场景就是在重写父类方法时，调用在父类中封装的方法实现

**调用父类方法的另一种方式**

在Python 2.x 时，如果需要调用父类的方法，还可以使用以下方式： 

```python
父类名.方法名(self)
```

### 父类的 私有属性 和 私有方法

1. 子类对象不能再自己的方法内部，直接访问父类的私有属性或私有方法
2. 子类对象可以通过父类的公有方法间接访问到私有属性或私有方法

> - 私有属性、方法是对象的隐私，不对外公开，外界以及子类都不能直接访问
> - 私有属性、方法通常用于做一些内部的事情

### 多继承

概念

- 子类可以拥有多个父类，并且具有所有父类的属性和方法
- 例如：孩子会继承自己父亲和母亲的特性

语法

```python
class 子类名(父类名1,父类名2):
	pass
```

一些注意事项：

1. 如果在不同的父类中拥有同名的方法，子类对象在调用方法时，会调用第一个继承的类的方法，程序员在开发时要尽量注意避免这种

**Python 中的 MRO ---> 方法搜索顺序**

- Python 中针对 类 提供了一个内置属性 `__mro__` 可以查看 方法 搜索顺序
- MRO 是 `method resolution order` ，主要用于在 多继承时判断 方法、属性 的调用路径

```python
class A:
    def test(self):
        print('我是A')
class B():
    def test(self):
        print('我是B')
class C(B, A):
    pass
print(C.__mro__)

```

会输出：

```
(<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>)
```

### 新式类与旧式（经典）类

> `object` 是 `Python` 为所有对象提供的基类，提供一些内置的属性和方法，可以使用 `dir` 函数查看

- 新式类：以 `object` 为基类的类，推荐使用
- 经典类：不以 `object` 为基类的类，不推荐使用
- 在 Python 3.x 中，如果没有制定父类，会默认使用 `object` 作为基类
- 在 Python 2.x 中，如果没有制定父类，不会默认使用 `object` 作为基类

### 多态

举个例子

1. 在 `Dog` 类中封装方法 `game`
   - 普通狗只是简单的玩耍
2. 定义 `XiaoTianDog` 继承自 `Dog`，并且重写 `game` 方法
   - 哮天犬需要在天上玩耍
3. 定义 `Person` 类，并且封装一个 **和狗玩** 的方法
   - 在方法内部，直接让 **狗对象** 调用 `game` 方法

**案例小结**

1. `Person` 类中只需要让 **狗对象** 调用 `game` 方法，而不关心具体是 **什么狗**
   - `game` 方法是在 `Dog` 父类中定义的
2. 在程序执行时，传入不同的 **狗对象** 实参，就会产生不同的执行效果

例子：

```python
class Dog(object):
    def __init__(self, name):
        self.name = name

    def game(self):
        print('%s 蹦蹦跳跳的玩耍...' % self.name)


class XiaoTianQuan(Dog):
    def game(self):
        print('%s 飞到天上去玩耍...' % self.name)


class Person(object):
    def __init__(self, name):
        self.name = name

    def game_with_dog(self, dog):
        print('%s 和 %s 快乐的玩耍...' % (self.name, dog.name))
        dog.game()


#wangcai = Dog("旺财")
wangcai = XiaoTianQuan("飞天旺财")
xiaoming = Person("小明")
xiaoming.game_with_dog(wangcai)

```

### 类属性和实例属性

- 类属性就是给类对象中定义的属性
- 通常用来记录与这个类相关的特征
- 类属性不会用于记录具体对象的特征

```python
class Tool(object):
    cnt = 0

    def __init__(self, name):
        self.name = name
        Tool.cnt += 1
```

### 类方法

- 类属性就是针对类对象定义的属性
  - 使用赋值语句在 `class` 关键字下方可定义类属性
  - 类属性用于记录与这个类相关的特征
- 类方法就是针对类对象定义的方法
  - 在类方法内部可以直接访问类属性或者调用其他的类方法

语法：

```python
@classmethod
def 类方法名(cls):
	pass
```

- 类方法需要使用装饰器 `@classmethod` 来标识，告诉解释器这是一个类方法
- 类方法的第一个参数应该是 `cls`
  - 由哪一个类调用的方法，方法内的 `cls` 就是哪一个类的引用
  - 这个参数和实例方法的第一个参数是 `self` 类似
  - 提示使用其他名称也可以，不过习惯使用 `cls`
- 通过 类名.调用 类方法，调用方法时，不需要传递 `cls` 参数
- 在方法内部：
  - 可以通过 `cls.` 访问类的属性
  - 也可以通过 `cls.` 调用其他类的方法

```python
class Tool(object):
    cnt = 0

    @classmethod
    def show_tool_count(cls):
        print('工具对象的数量 %d' % cls.cnt)

    def __init__(self, name):
        self.name = name
        Tool.cnt += 1

t1 = Tool('斧头')
t2 = Tool('榔头')
Tool.show_tool_count()
```

### 静态方法

- 在开发时，如果需要在类中封装一个方法，这个方法：
  - 既不需要访问实例属性或者调用实例方法
  - 也不需要访问类属性或者调用类方法
- 这个时候可以把这个方法封装成一个静态方法

语法如下：

```python
@staticmethod
def 静态方法名():
	pass
```

- 静态方法需要用装饰器 `@staticmethod` 来标识，告诉解释器这是一个静态方法
- 通过类名.调用静态方法

```python
class Dog(object):
    @staticmethod
    def run():
        print('小狗要跑...')

    def __init__(self, name):
        self.name = name

```

### 综合案例

**需求**

1. 设计一个 `Game` 类
2. 属性：
   - 定义一个 **类属性** `top_score` 记录游戏的 **历史最高分**
   - 定义一个 **实例属性** `player_name` 记录 **当前游戏的玩家姓名**
3. 方法：
   - **静态方法** `show_help` 显示游戏帮助信息
   - **类方法** `show_top_score` 显示历史最高分
   - **实例方法** `start_game` 开始当前玩家的游戏
4. 主程序步骤
   - 1) 查看帮助信息
   - 2) 查看历史最高分
   - 3) 创建游戏对象，开始游戏

![](https://i.loli.net/2019/03/27/5c9ae700e7b27.png)

#### 案例小结

1. 实例方法—— 方法内部需要访问实例属性
   - **实例方法** 内部可以使用 **类名.** 访问类属性
2. **类方法** —— 方法内部 **只** 需要访问 **类属性**
3. **静态方法** —— 方法内部，不需要访问 **实例属性** 和 **类属性**

实现：

```python
class Game(object):
    # 历史最高分
    top_score = 0

    def __init__(self, player_name):
        self.player_name = player_name

    # 显示帮助
    @staticmethod
    def show_help():
        print('帮助信息：让僵尸进入大门')

    # 显示最高分
    @classmethod
    def show_top_score(cls):
        print('历史记录 %d' % cls.top_score)

    def start_game(self):
        print('%s 开始游戏了...' % self.player_name)


# 查看帮助信息
Game.show_help()
# 查看历史最高分
Game.show_top_score()
# 创建游戏对象
game = Game("小明")
game.start_game()
```

### 单例模式

- 目的：让 类 创建的对象，在系统中只有唯一的一个实例
- 每一次执行 `类名()` 返回的对象，内存地址是相同的

#### `__new__`  方法

- 使用 `类名()` 创建对象时，Python 解释器会首先调用 `__new__` 方法为对象分配空间
- `__new__` 是一个由 `object` 基类提供的内置静态方法，主要作用有两个：
  1. 在内存中为对象分配空间
  2. 返回对象的引用
- Python 的解释器获得对象的引用之后，将引用作为第一个参数，传递给 `__init__` 方法

> 重写 `__new__` 方法的代码非常固定

- 重写 `__new__` 方法一定要 `return super().__new__(cls)`
- 否则 Python 的解释器得不到分配了的对象引用，就不会调用对象的初始化方法
- `__new__` 是一个静态方法，在调用时需要主动传递 `cls` 参数

使用例子：

```python
# __new__ 方法的使用
class MusicPlayer(object):

    def __new__(cls, *args, **kwargs):
        # 创建独享时，new 方法会被自动调用
        print('创建对象，分配空间')
        return super().__new__(cls)

    def __init__(self):
        print('播放器初始化')


player = MusicPlayer()
print(player)

```

单例模式：

```python
class MusicPlayer(object):
    # 记录第一个被创建的对象引用
    instance = None

    def __new__(cls, *args, **kwargs):
        if cls.instance is None:
            cls.instance = super().__new__(cls)
        return cls.instance


p1 = MusicPlayer()
print(p1)
p2 = MusicPlayer()
print(p2)

```

#### 只执行一次初始化工作

- 在每次使用 `类名()` 创建对象时，Python都会调用 `__new__` 和 `__init__` 
- 在上面的代码中，虽然改造了 `__new__` ，但是每次都会得到第一次创建对象的引用
- 所以要解决初始化方法被重复调用的问题

需求：

- 让初始化动作只被执行一次

解决办法：

用一个变量进行标记，初始值为 `False` ，然后判断执行

