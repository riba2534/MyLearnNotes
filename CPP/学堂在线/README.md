## 学堂在线笔记

[基于Linux的C++（自主模式）](http://www.xuetangx.com/courses/course-v1:TsinghuaX+20740084X+sp/about)

相关代码在同目录下。

### 5.5作用域与生存周期

1. 作用域:标识符的有效范围
2. 可见性:程序中某个位置是否可以使用标识符
3. 标识符仅在作用域内可见，位于作用域的标识符不一定可见
4. 单独出现的花括号作用是引入**嵌套块**
5. 允许在块中定义数据对象，作用域仅限于本块
6. 如果一个源文件里有全局变量，作用域会扩展，所以**不能在头文件中定义全局变量**
7. 在一个被屏蔽全局量的语句块里面，如果想访问全局量i，那么就使用`::i`的方式来访问
8. `static`修饰局部变量，可以使局部变量拥有静态生存期,程序退出该块的时候局部变量仍然存在，并且下次进入该块时使用上一次的数据值
9. 静态局部变量一定要初始化
10. 在一个函数前面用`static`关键字修饰，那么这个函数就是一个内部函数，这个不能背外部函数库引用
11. 声明与定义:定义是产生一个实体，声明是在函数中引用进来一个实体

### 6.3数组

1. 数组作为函数参数的时候，可以把函数对数组的修改带出去

### 7.5 指针与复合数据类型

指针的取员操作符：

- `.`左边必须为实体
- `->`左边必须为指针

![](https://i.loli.net/2018/12/24/5c2071ea22e56.png)

### 7.7/7.8 动态内存管理

**malloc的使用:**

```cpp
int *p = (int *)malloc(n * sizeof(int));//分配一个n个整数的动态数组
```

- 使用`malloc`申请内存以后必须用`free`释放掉
- 一个指针被释放掉以后，最好指向`NULL`，比如:`p = NULL`

new的使用，动态创建单个目标数据对象：

```cpp
int *p;
p = new int;
*p = 10;
```

或者：

```cpp
int *p;
p = new(int);
*p = 10;
```

销毁的时候`delete p`即可.

- `malloc`和`free`搭配
- `new`和`delete`搭配
- 一定不要混用
- 在用`delete`销毁数组的时候，用`delete []p`，不能写反。

**指针使用的一般原则:**

- 主动释放原则：如果某函数动态分配了内存， 在函数退出时该目标数据对象不在需要，应主动释它，此时 malloc 与 free 在函数中成对出现。
- 所有权转移原则：如果某函数动态分配了内存，在函数退出后该目标数据对象仍然需要，此时应该将其所有权转交给本函数之外的同型指针对象，函数内部代码只有 malloc，没有 free 。

**空悬指针问题：**

所有权的重叠：指针赋值操作导致两个指针数据对象指向指向同样的目标数据对象，即两个指针都**声称自己拥有目标数据对象的所有权**，例如:

```cpp
int *p, *q;
q = (int *)malloc(sizeof(int));
p = q;
```

产生原因，如果在程序中通过某个指针释放了目标数据对象，另一指针并不了解这种情况，他仍然指向不再有效的数据对象，导致空悬指针出现.

```cpp
free(p);
p=NULL;
```

虽然此时已经释放了 p  ，但是并没有改 q 。

解决方案：确保程序中只有唯一的一个指针指向目标数据对象，只有它负责目标数据对象的存储管理，其他指针只可以访问，不可管理，若目标数据对象仍有使用价值，但该指针不再有效，此时应该将所有权移交。

**内存泄露与垃圾回收**：

产生原因：若某个函数通过局部指针变量动态分配了一个目标数据对象内存，在函数调用结束候没有释放该内存，并且所有权没有上交。

```cpp
void f()
{
    int *p = new int;
    *p = 10;
}
```

函数 f 结束后, *p 所指向的存储空间仍然存在，但是却没有任何指针对象拥有它，故不可访问。

问题的实质是**动态分配的内存必须动态释放，函数本身并不负责管理它**。

> 垃圾回收机制，系统负责管理，程序员不需要主动去释放动态分配的内存，Java 有此功能，C语言无。

### 7.9 引用

引用的定义格式：

```cpp
数据类型& 变量名称 = 被引用变量名称;
int a;
int& ref = a;
```

引用的性质：

- 引用类型的变量，不占用单独的存储空间
- 为另一数据对象起别名，与该对象同享存储空间
- 对引用变量类型的操作就是对被引用变量的操作

引用的重要用途：

- 作为函数参数

  - 参数传递机制，引用传递，直接修改实际参数值
    - 使用格式`返回值类型 函数名称(类型 & 参数名称)`

- 常量引用：既能引用常量，不能通过引用改变目标对象值；引用本身也不能改变引用对象

  - 引用作为函数返回值时不生成副本

  - 函数示例：

    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    int &Inc(int &dest, const int &alpha)
    {
        dest += alpha;
        return dest;
    }
    int main()
    {
        int a = 10, b = 20, c;
        c = Inc(a, b)++;
        printf("a=%d,b=%d,c=%d\n", a, b, c);
        return 0;
    }
    ```

    这个函数首先把 b 累加到 a 上去，然后返回的是 a ，最后给 c 赋值之后，再给 a 加 1 .



 
